
pre-2026

* Re-implement the FD read and FD UDP read methods to use EV_PERSIST
  correctly:
  + have an fde_comm flag to say "yes, i've added the event"
  + have an fde_comm flag to say "yes, I've seen an FD_READ event
    but I've not done any IO yet"
  + when someone registers for a comm udp read or comm_read, check
    if the fde_comm flag above indiciates that an FD_READ event
    has been seen, and if so, schedule the ready callback to try
    doing IO
  + And once recvfrom() or read() is done, clear that flag.
  + .. and on error, just delete the event and clear the flags
    above.

  The aim here is to make the FD read code only need to register
  a read FD event once and keep it persistent for the lifespan
  of the commfd state - regardless of whether there's an active
  IO callback going on.

* .. same with comm FD / comm UDP FD write

2026

* migrate the FD operations (eg the non blocking call) into
  a separate source file or util library here

* bring in libdebug into this mess and start leveraging it here

* look at the srv/clt (and udp srv/clt) connection representation;
  there's a lot of duplicate work here which I think belongs in libiapp.

* .. ie, ideally libiapp would take care of all of the socket and
  file descriptor related shenanigans.

* add unix pipe, unix socket stuff

* actually flesh out the disk IO stuff via worker threads

* figure out a 'thread queue' representation that contains that 'fde_head'
  representation, or something similar to this.


Ideally a demo app should be written which doesn't do any of its own
socket, disk, filedescriptor, etc work by itself.

* implement EVFILT_USER to queue oneshot trigger events into a kqueue
  worker thread to wake it up.  Add that abstraction to fde.[ch] and
  the worker queue and the thread pool stuff.

